1. Множественное наследование. Порядок разрешения методов (MRO). Представьте, что у нас есть классы "Инженер" и "Артист", а ты создаешь класс "Инженер-Артист", который наследует от обоих. Если в обоих классах есть метод "работать()", то какой из них должен выполниться? Python использует строгий алгоритм под названием MRO (Method Resolution Order - порядок разрешения методов). Этот алгоритм (C3) строит линейный порядок наследования для класса. Проще говоря, он составляет список всех родителей в определенной последовательности. Когда ты вызываешь метод, Python идет по этому списку слева направо и ищет метод в первом же классе, где он найден. Посмотреть этот порядок можно так: print(ИнженерАртист.__mro__). Это гарантирует предсказуемость и решает "проблему ромба", когда один класс может быть достигнут разными путями.

2. Статический (Ad hoc) полиморфизм. Это умение одной и той же операции или имени функции работать по-разному в зависимости от типов данных, с которыми она работает, причем это определяется на этапе компиляции или написания кода. Самый наглядный пример - встроенный оператор плюс +. Когда ты пишешь a + b, для чисел это будет арифметическая сумма, а для строк - склеивание (конкатенация). Компилятор или интерпретатор, видя типы операндов, выбирает нужную реализацию. В языках, которые поддерживают перегрузку функций (как C++ или Java), ты можешь сам создать несколько функций с одним именем, но разными типами параметров. Компилятор выберет ту, которая подходит по типам. В Python такого прямого перегруза функций нет, но ad hoc полиморфизм реализуется через перегрузку операторов (теми самыми "магическими" методами вроде `__add__`) и через проверку типов аргументов внутри функции вручную.

3. "Утиная" типизация. Это философия Python и многих динамических языков, которая гласит: "Если что-то ходит как утка и крякает как утка, то это утка". На практике это означает, что тип объекта определяется не его классом (не тем, что написано в его "паспорте"), а его поведением - наличием у него нужных методов и атрибутов. Тебе не нужно, чтобы объект был экземпляром конкретного класса "Утка" или наследовался от него. Тебе важно, чтобы у него был метод quack(). Если он есть - ты можешь его вызвать. Это дает огромную гибкость: ты можешь написать функцию, которая работает с любым объектом, у которого есть, например, метод draw(). Неважно, будет это объект "Круг", "Квадрат" или "График". Это ослабляет связность кода, но требует дисциплины: если ты передашь объект без нужного метода, программа упадет с ошибкой во время выполнения.

4. Внутренние (вложенные) классы. Это классы, объявленные внутри другого класса. Они нужны для логической организации кода, когда один класс имеет смысл только в контексте другого. Например, у тебя есть класс Автомобиль. Вполне логично внутри него описать класс Двигатель, потому что в отрыве от автомобиля понятие двигателя может быть слишком абстрактным. Вложенный класс имеет доступ к атрибутам внешнего класса, но только через экземпляр внешнего класса. Это нечасто используемая возможность, но она помогает показать сильную семантическую связь и скрыть вспомогательную логику внутри основного класса, не засоряя глобальное пространство имен. Однако в Python зачастую проще и понятнее использовать композицию - просто создать отдельный класс Двигатель и хранить его экземпляр как атрибут в Автомобиле.

5. Конструкторы и деструкторы. Конструктор - это специальный метод, который автоматически вызывается при создании нового объекта. В Python это метод __init__(self, ...). Его задача - проинициализировать объект, то есть задать начальные значения его полям (атрибутам). Когда ты пишешь obj = MyClass(10), происходит следующее: создается пустой объект, а затем вызывается MyClass.__init__(obj, 10), где 10 - это твой аргумент. Деструктор - это метод __del__(self). Он вызывается, когда объект собираются уничтожить, чтобы освободить память. Но на него нельзя полагаться в Python! Момент его вызова определяется сборщиком мусора, и он может быть вызван намного позже, чем ты ожидаешь, или вообще не вызван. Поэтому для освобождения ресурсов (открытые файлы, сетевые соединения) используют контекстные менеджеры (`with` statement) или явный метод close().

6. Перегрузка операций. Операция сложения. Перегрузка позволяет определить, как будут вести себя стандартные операторы (вроде +, -, *`) для объектов твоего собственного класса. Чтобы перегрузить сложение, в классе нужно реализовать метод `__add__(self, other). Когда ты пишешь a + b, Python интерпретирует это как a.__add__(b). Внутри этого метода ты должен описать логику "сложения" двух объектов и вернуть результат - как правило, новый объект того же класса. Например, для класса Вектор метод __add__ будет складывать соответствующие координаты двух векторов и возвращать новый вектор с результатом. Это делает код интуитивно понятным: использование знака + для твоих объектов выглядит естественно.

7. Перегрузка операций. Операция сравнения (часть 1). Аналогично сложению, операции сравнения (`==`, !=, <, >, <=, >=`) тоже можно перегрузить, чтобы сравнивать объекты по твоим правилам. Для этого используются методы `__eq__ (равно), __ne__ (не равно), __lt__ (меньше), __gt__ (больше), __le__ (меньше или равно), __ge__ (больше или равно). Когда ты пишешь a > b, Python вызывает a.__gt__(b). Твоя задача - сравнить объекты self и other по какому-то значимому критерию и вернуть True или False. Например, для класса Книга сравнение book1 > book2 может означать сравнение по количеству страниц. Важно соблюдать логическую согласованность: если a == b истинно, то a != b должно быть ложно.

8. Перегрузка операций. Операция сравнения (часть 2). Важно понимать, что перегрузка сравнений не только для чисел. Ты можешь определить, что один объект "меньше" другого, например, по приоритету, по дате создания или по алфавиту имени. Это позволяет использовать твои объекты в стандартных функциях, которые ожидают сравниваемые элементы, например, в sorted() для сортировки списка твоих объектов. Python также предоставляет декоратор @functools.total_ordering. Если ты определишь хотя бы __eq__ и один из методов __lt__, __le__, __gt__ или __ge__, этот декоратор автоматически сгенерирует остальные методы сравнения, избавляя от рутины.

9. Генерация исключений. Исключения - это механизм обработки ошибок и нестандартных ситуаций. Когда в программе происходит что-то непредвиденное (попытка открыть несуществующий файл, деление на ноль), вместо аварийного завершения можно "сгенерировать" (или "выбросить") исключение. Делается это оператором raise. Например: raise ValueError("Неверное значение"). При этом создается объект-исключение (экземпляр класса, унаследованного от BaseException`). Выполнение текущего блока кода немедленно прерывается, и Python начинает искать ближайший блок `try/except, который может это исключение обработать. Если обработчик не найден, программа завершается с выводом трассировки ошибки. Это позволяет отделить нормальную логику программы от кода обработки сбоев.

10. Сериализация и десериализация. Файлы JSON. Сериализация - это процесс превращения объекта или структуры данных в последовательность байт или строку, которую можно сохранить (в файл) или передать (по сети). Десериализация - обратный процесс восстановления объекта из этой последовательности. JSON (JavaScript Object Notation) - это очень популярный текстовый формат для обмена данными. Он человекочитаем и поддерживается всеми языками. В Python для работы с ним есть модуль json. Он умеет сериализовывать базовые типы Python: словари, списки, строки, числа, булевы значения и None. Чтобы сохранить объект своего класса в JSON, ты сначала должен преобразовать его в один из этих базовых типов (например, в словарь с атрибутами), а потом сериализовать этот словарь. При десериализации ты получишь словарь, из которого можно будет создать новый объект.

11. Сериализация и десериализация. Pickle.  В отличие от JSON, модуль pickle предназначен для сериализации практически любых объектов Python, включая сложные, с циклическими ссылками и пользовательскими классами. Он преобразует объект в поток байтов. Это мощно и удобно для сохранения состояния программы или кэширования вычисленных данных между запусками одной программы. Однако у pickle есть серьезные недостатки. Во-первых, формат специфичен для Python, и другие языки его не поймут. Во-вторых, и это главное, он небезопасен. При десериализации (загрузке) pickle может выполнить произвольный код, что делает его уязвимым для атак. Поэтому правило простое: НИКОГДА не загружайте pickle-данные из ненадежных или непроверенных источников. Используйте его только для внутренних нужд программы.

12. Классы для работы с файлами и каталогами. Для операций с файловой системой в Python есть несколько модулей. os и os.path предоставляют низкоуровневые функции: создание/удаление папок (`os.mkdir`, os.rmdir`), проверка существования (`os.path.exists`), работа с путями (`os.path.join`). Более высокоуровневая библиотека `shutil позволяет копировать, перемещать и удалять целые деревья каталогов. Самый современный и удобный способ - модуль pathlib (появился в Python 3.4). В нем путь - это не строка, а объект Path, у которого есть методы: .exists(), .is_file(), .mkdir(), .open(), .glob() для поиска файлов по шаблону. Это объектно-ориентированный подход, который делает код чище и понятнее.

13. Классы для работы с датой и временем. Основная работа ведется через модуль datetime. Ключевые классы там: datetime.datetime (хранит дату и время вместе), datetime.date (только дата), datetime.time (только время) и datetime.timedelta (разница между двумя моментами времени, интервал). С их помощью можно создавать объекты, представляющие конкретный момент (`datetime.now()`), парсить даты из строк (`datetime.strptime()`), форматировать их в строки (`strftime()`). Самое полезное - выполнять арифметику с датами: завтра = сегодня + timedelta(days=1). Это избавляет от ручных расчетов с високосными годами, количеством дней в месяце и т.д.

14. Оконные классы. В контексте GUI-программирования (например, на Tkinter) оконные классы - это базовые контейнеры, которые представляют собой окна или их части. Главный класс - Tk - это корневое окно приложения. Toplevel - дополнительное независимое окно. Frame - прямоугольная область внутри окна, которая используется для группировки других виджетов (кнопок, текстовых полей). Эти классы управляют геометрией, фоном, границами и являются родительскими контейнерами для всех остальных элементов интерфейса. Создание экземпляра Tk() - обязательный первый шаг в любом Tkinter-приложении.

15. Обработка событий клавиатуры и мыши. В GUI приложение работает по событийно-ориентированной модели. Событие - это действие пользователя: нажатие клавиши (`<KeyPress>`), щелчок мыши (`<Button-1>`), движение мыши (`<Motion>`). Для обработки этих событий используется механизм привязки (binding). Ты "привязываешь" определенное событие на виджете (например, на кнопке или на всем окне) к функции-обработчику (callback). Когда событие происходит, фреймворк GUI вызывает эту функцию и передает ей объект события, содержащий детали (какая клавиша нажата, координаты мыши). Вся логика отклика программы на действия пользователя строится внутри таких функций-обработчиков.

16.Основные подходы к разработке ПО. Понятие ООП. Исторически сначала был императивный подход (просто последовательность команд), затем структурный (с функциями и процедурами для борьбы со сложностью). Объектно-Ориентированное Программирование (ООП) - это парадигма, где программа представляется как набор объектов, которые взаимодействуют друг с другом. Каждый объект - это экземпляр класса, который объединяет в себе данные (атрибуты, поля) и методы (функции) для работы с этими данными. Ключевые идеи: инкапсуляция (сокрытие деталей реализации), наследование (возможность создавать новые классы на основе существующих) и полиморфизм (способность объектов с одинаковым интерфейсом иметь разную реализацию). ООП помогает моделировать сложные системы, приближая программные сущности к объектам реального мира.

17. История развития ООП, классификация языков, объектная декомпозиция. ООП зародилось в 1960-х годах в языке Simula, где впервые появились понятия классов и объектов. Расцвет пришелся на 1970-е с языком Smalltalk, который был полностью объектно-ориентированным. Затем идеи переняли гибридные языки, такие как C++ и Objective-C, которые добавили ООП на top of Си. В 1990-х появились Java и C#, сделавшие ООП мейнстримом. Языки можно классифицировать на чистые ООП (Smalltalk, где всё - объект) и гибридные (Python, C++, где есть и объекты, и примитивные типы). Объектная декомпозиция - это метод анализа и проектирования системы, при котором она разбивается не на функции, а на взаимодействующие объекты, отвечающие за разные аспекты предметной области. Это помогает управлять сложностью крупных проектов.

18. Объектная модель программы. Определения, отношения. Объектная модель - это способ организации программы в ООП. Ее основные понятия: Класс - это шаблон, "чертеж", описывающий структуру (атрибуты) и поведение (методы) объекта. Объект (экземпляр) - это конкретная реализация класса, созданная в памяти. Атрибут - это переменная, принадлежащая объекту или классу. Свойство (property) - это специальный атрибут, доступ к которому управляется через методы getter и setter, что позволяет контролировать присвоение значений. Отношения между классами бывают разные: Ассоциация ("использует" - один объект знает о другом), Агрегация ("имеет" часть, часть может существовать отдельно), Композиция ("содержит" часть, часть не существует отдельно от целого), Наследование ("является" разновидностью).

19. UML. Диаграмма прецедентов (часть 1). UML (Unified Modeling Language) - это стандартный графический язык для визуализации, проектирования и документирования программных систем. Диаграмма прецедентов (Use Case Diagram) - это один из видов диаграмм UML, который показывает взаимодействие между системой (например, разрабатываемым программным обеспечением) и внешними сущностями - акторами. Актор - это роль, которую играет пользователь или другая система, взаимодействующая с нашей системой. Прецедент (Use Case) - это законченная, целостная функция системы, которую она выполняет по запросу актора. Диаграмма изображает акторов (человечки), прецеденты (овалы) и связи между ними. Она отвечает на вопрос "Что система должна делать для пользователя?" и используется на этапе сбора требований.

20. UML. Диаграмма прецедентов (часть 2). Помимо акторов и прецедентов, на диаграмме могут отображаться отношения. Ассоциация - связь между актором и прецедентом. Включение (include) - когда один прецедент обязательно включает в себя поведение другого (например, "Оплатить заказ" *включает* "Авторизовать карту"). Расширение (extend) - когда один прецедент может (при определенных условиях) расширять поведение другого (например, "Заказать товар" *может быть расширен* прецедентом "Применить промокод"). Диаграмма прецедентов не описывает внутреннюю логику системы и последовательность шагов - для этого есть диаграммы последовательностей или активностей. Ее цель - задать границы системы и перечень ее основных функций с точки зрения внешнего пользователя.

21.Принципы объектно-ориентированного программирования. Помимо трех основных "китов" (инкапсуляция, наследование, полиморфизм), есть важные производные принципы, часто объединяемые в аббревиатуру SOLID. S (Single Responsibility) - принцип единственной ответственности: класс должен иметь только одну причину для изменения. O (Open-Closed) - принцип открытости/закрытости: класс должен быть открыт для расширения (наследование), но закрыт для модификации. L (Liskov Substitution) - принцип подстановки Барбары Лисков: объекты подкласса должны быть способны заменить объекты родительского класса без нарушения работы программы. I (Interface Segregation) - принцип разделения интерфейсов: много специализированных интерфейсов лучше одного общего. D (Dependency Inversion) - принцип инверсии зависимостей: зависеть нужно от абстракций, а не от конкретных классов.

22. Типовые компоненты для обслуживания баз данных. В мире разработки под Windows (например, Delphi, C++Builder) и .NET существует понятие визуальных компонентов для работы с БД. К ним относятся: Connection (компонент подключения - настраивает параметры соединения с сервером БД, тип драйвера, логин, пароль), Query или Command (компонент запроса - содержит текст SQL-запроса или хранимой процедуры для выборки или модификации данных), DataSet (набор данных - виртуальное хранилище данных в памяти, часто в виде таблиц со связями), DataAdapter (адаптер данных - "мост" между источником данных и DataSet, умеет выполнять запросы и заполнять DataSet, а также отправлять изменения обратно в БД).

23. Источники данных и компоненты доступа к базам данных. Источником данных может быть что угодно: реляционная база данных (MySQL, PostgreSQL), файл (Excel, XML, CSV), веб-сервис. Для доступа к ним используются специальные компоненты и технологии. Драйверы БД (ODBC, JDBC, специфичные драйверы) - низкоуровневое ПО для связи с конкретной СУБД. Провайдеры данных (Data Provider в .NET) - набор классов, предоставляющих единый интерфейс для работы с разными БД. ORM-системы (Object-Relational Mapping, например, SQLAlchemy в Python, Hibernate в Java) - это высокоуровневые фреймворки, которые автоматически отображают таблицы базы данных на классы в коде, а строки - на объекты. Это избавляет программиста от написания большого количества рутинного SQL-кода.

24. Рефлексия и интроспекция. Интроспекция - это способность программы исследовать тип и свойства объекта во время выполнения. В Python это очень просто: с помощью функций типа type(), isinstance(), hasattr(), getattr(), dir() ты можешь узнать, что из себя представляет объект, какие методы и атрибуты у него есть, и даже вызвать эти методы по имени. Рефлексия - это более широкое понятие, включающее не только исследование, но и модификацию структуры и поведения программы на лету (например, динамическое создание классов, изменение атрибутов). Python обладает мощными возможностями рефлексии, что используется во многих фреймворках (например, для автоматической регистрации классов, создания форм на основе моделей данных). Это позволяет писать очень гибкий и абстрактный код.

25. Полиморфизм: назначение и семантика. Назначение полиморфизма - позволить единообразно работать с объектами разных типов, если они поддерживают общий интерфейс (набор методов). Семантика (смысл) в том, что ты пишешь код, который зависит не от конкретного класса объекта, а от его способности отреагировать на определенное сообщение (вызов метода). Например, у тебя есть функция draw_shape(shape). В нее можно передать объект класса Круг, Квадрат или Треугольник. Если все эти классы имеют метод draw(), функция просто вызовет shape.draw(), и каждый объект нарисуется по-своему. Полиморфизм делает систему расширяемой: чтобы добавить новую фигуру, нужно лишь создать новый класс с методом draw(), не меняя существующий код функции draw_shape.

26. Инкапсуляция и области видимости. Защита на уровне объекта и класса. Инкапсуляция - это сокрытие внутреннего устройства объекта и данных от внешнего мира, предоставление только безопасного интерфейса. В Python инкапсуляция реализована на уровне соглашения. Области видимости: публичные атрибуты (public, например, self.name`), защищенные (protected, одно подчеркивание `_name - сигнал программисту "не трогай, это для внутреннего использования"), приватные (private, два подчеркивания __name - Python искажает имя, чтобы затруднить доступ извне, но не делает его полностью недоступным). Защита на уровне объекта - это когда каждый экземпляр хранит свои собственные данные. Защита на уровне класса - это атрибуты и методы самого класса (статические), они общие для всех объектов. Полной изоляции, как в Java, в Python нет, что возлагает ответственность на разработчика за соблюдение соглашений.

27.Абстрактные типы данных и классы. Сравнение.  Абстрактный тип данных (АТД) - это математическая модель, которая определяет тип данных исключительно через набор операций, которые можно с ним выполнять, и их поведение, скрывая детали реализации. Например, АТД "Стек" определяется операциями push (добавить) и pop (извлечь). Абстрактный класс в программировании - это класс, который не предназначен для создания экземпляров. Он служит шаблоном для других классов и часто содержит объявления методов без реализации (абстрактные методы). Его цель - задать общий интерфейс для группы родственных классов. Сравнение: АТД - это теоретическое понятие, концепция. Абстрактный класс - это конкретная языковая конструкция для реализации этой концепции, обеспечивающая единый интерфейс и принуждая наследников реализовать определенные методы.

28. Визуальные компоненты для работы с данными. В средах быстрой разработки (RAD) это готовые элементы интерфейса, которые умеют отображать и редактировать данные, полученные из источника (например, из DataSet или результата SQL-запроса). Основные компоненты: DataGrid/TableView (таблица для отображения данных в виде строк и столбцов с возможностью сортировки и редактирования), ListBox/ComboBox (список для выбора значения), TreeView (иерархический список, например, для отображения папок и файлов). Их ключевая особенность - поддержка привязки данных (data binding): ты связываешь свойство компонента (например, `DataGrid.ItemsSource`) с источником данных, и компонент автоматически отображает данные и отправляет изменения обратно. Это минимизирует код, необходимый для построения пользовательских интерфейсов, работающих с БД.
